/*************************************************************************\
*    Part of the TISCH framework - see http://tisch.sourceforge.net/      *
*   Copyright (c) 2006 - 2011 by Florian Echtler <floe@butterbrot.org>    *
*   Licensed under GNU Lesser General Public License (LGPL) 3 or later    *
\*************************************************************************/

#ifndef _FILTER_H_
#define _FILTER_H_

#include <tinyxml.h>
#include <algorithm>

#include <fstream>

#include "GLUTWindow.h"
#include "ShortImage.h"
#include "IntensityImage.h"
#include "RGBImage.h"

#ifdef HAS_UBITRACK
#include "MarkerTracker.h"
#endif

class Filter {

	public:

		Filter( TiXmlElement* _config = 0, Filter* _input = 0 ):
			shmid(0), input(_input), result(0.0), config(_config), image(NULL), shortimage(NULL), rgbimage(NULL)
		{ 
			if (config) config->QueryIntAttribute("ShmID",&shmid);
			// init switching variable for Configurator options
			toggle = 0;
			MAX_VALUE = 65535;
			if(input != 0) {
				useIntensityImage = input->getUseIntensityImage();
#ifdef HAS_FREENECT
				displayRGBImage = input->getdisplayRGBImage();
#endif
			}
		}

		virtual ~Filter() { delete image; delete shortimage; delete rgbimage; }

		void checkImage() {
			if (!image) {
				IntensityImage* inputimg = input->getImage();
				int w = inputimg->getWidth();
				int h = inputimg->getHeight();
				image = new IntensityImage( w, h, shmid, 1 );
			}
			if (/*TODO: do we have to add this? !useIntensityImage &&*/ !shortimage) {
				ShortImage* inputimg = input->getShortImage();
				int w = inputimg->getWidth();
				int h = inputimg->getHeight();
				shortimage = new ShortImage( w, h );
			}
#ifdef HAS_FREENECT
			if(!rgbimage) {
				RGBImage* inputimg = input->getRGBImage();
				int w = inputimg->getWidth();
				int h = inputimg->getHeight();
				rgbimage = new RGBImage( w, h );
			}
#endif
		}

		virtual int process() = 0;
		virtual void reset(int initialReset) { }
		virtual void processMouseButton(int button, int state, int x, int y) { }

		// TODO: print filter information
		virtual void draw( GLUTWindow* win ) {
			if(useIntensityImage)
				win->show( *image, 0, 0 );
#ifdef HAS_FREENECT
			else if( displayRGBImage )
				win->show( *rgbimage, 0, 0 );
#endif
			else
				win->show( *shortimage, 0, 0 );
		}
		virtual void link( Filter* _link   ) { }

		virtual IntensityImage* getImage() { return image; }
		virtual ShortImage* getShortImage() { return shortimage; }
		virtual RGBImage* getRGBImage() { return rgbimage; }
		virtual double getResult() { return result; }

		// Configurator functions
		void nextOption() { toggle = (countOfOptions > 0) ? ((toggle + 1) % countOfOptions) : toggle; }
		int getCurrentOption() { return toggle; }
		const int getOptionCount() { return countOfOptions; }
		virtual const char* getOptionName(int option) { return ""; };
		virtual double getOptionValue(int option) { return -1;};
		virtual void modifyOptionValue(double delta, bool overwrite) { };
		int getUseIntensityImage() { return useIntensityImage; };
		virtual TiXmlElement* getXMLRepresentation() {return new TiXmlElement( "something_went_wrong" );};
		Filter* getParent() {return input;};
#ifdef HAS_FREENECT
		int getdisplayRGBImage() { return displayRGBImage; };
		void showRGBImage() { displayRGBImage = (displayRGBImage + 1) % 2; };
#endif
	protected:

		int shmid;
		Filter* input;
		double result;
		TiXmlElement* config;
		IntensityImage* image;
		ShortImage* shortimage;
		RGBImage* rgbimage;
		int useIntensityImage;
		// Configurator
		int displayRGBImage;
		int toggle; // initialized in basic Filter constructor
		int MAX_VALUE; // initialized in basic Filter constructor
		int countOfOptions; // Initialization required in each subfilter class !
		int resetOnInit;
};


class BGSubFilter: public Filter {
	public:
		BGSubFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual ~BGSubFilter();
		virtual int process();
		virtual void reset(int initialReset);
		virtual void link( Filter* _mask );
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
		int getBGSubFilterID();
		TiXmlElement* getXMLofBackground(int BGSubFilterID, std::string pathToSaveBackgroundIMG);
		void loadFilterOptions(TiXmlElement* OptionSubtree, bool debug);
		int loadPGMImageFromFile(std::string filename, bool debug);
	protected:
		ShortImage* background;
		Filter* mask;
		int invert, adaptive, storeBGImg;
		int BGSubFilterID; 

};

class FlipFilter: public Filter {
	public:
		FlipFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		// Options
		int hflip;
		int vflip;
};

class ThreshFilter: public Filter {
	public:
		ThreshFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		int THRESH_MAX; // 255 if intensity image is used, else 2047
		// Options
		int threshold_min;
		int threshold_max;
};

class SpeckleFilter: public Filter {
	public:
		SpeckleFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		int noiselevel;
};

class LowpassFilter: public Filter {
	public:
		LowpassFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		int mode, range;
};

class BandpassFilter: public Filter {
	public:
		BandpassFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		int inner, outer;
};

class SplitFilter: public Filter {
	public:
		SplitFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		virtual void reset();
		virtual IntensityImage* getImage();
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		IntensityImage* image2;
		int incount, outcount;
};

class AreaFilter: public Filter {
	public:
		AreaFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		virtual void reset(int initialReset);
		virtual void processMouseButton(int button, int state, int x, int y);
		void generateEdgepoints( std::vector<Point*> cornerpoints );
		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		virtual void draw( GLUTWindow* win );
		virtual TiXmlElement* getXMLRepresentation();
		int getAreaFilterID();
		TiXmlElement* getXMLofAreas(int AreaFilterID);
		void loadFilterOptions(TiXmlElement* OptionSubtree, bool debug);
		int createFilterAreaFromConfig(TiXmlElement* PolygonsOfAreaFilter, bool debug);
	protected:
		int enabled;
		int AreaFilterID;
		bool updated;
		std::vector<int> edgepoints;
		std::vector<std::vector<Point*> > cornerpointvector;
		 
};

#ifdef HAS_UBITRACK
class MarkerTrackerFilter: public Filter {
	public:
		MarkerTrackerFilter( TiXmlElement* _config = 0, Filter* _input = 0 );
		virtual int process();
		virtual void draw( GLUTWindow* win );
		virtual ~MarkerTrackerFilter();

		// Configurator
		virtual const char* getOptionName(int option);
		virtual double getOptionValue(int option);
		virtual void modifyOptionValue(double delta, bool overwrite);
		
		virtual TiXmlElement* getXMLRepresentation();
	protected:
		// variables to read from XML
		int int_mt_enabled;
		int int_mt_showMarker;
		
		// variables for further use
		bool mt_enabled;
		bool mt_showMarker;
		MarkerTracker* mMarkerTracker;
		std::vector<Ubitrack::Vision::SimpleMarkerInfo>* detectedMarkers;

};
#endif // HAS_FREENECT

#endif // _FILTER_H_
